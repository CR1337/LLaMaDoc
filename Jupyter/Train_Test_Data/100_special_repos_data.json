[{"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def _is_package(path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return (\n        os.path.isdir(path)\n        and os.path.exists(os.path.join(path, '__init__.py'))\n    )<|fim_middle|>Is the given path a Python package?<|file_separator|>", "l": true, "c": "def _is_package(path):\n    return (\n        os.path.isdir(path)\n        and os.path.exists(os.path.join(path, '__init__.py'))\n    )", "d": "Is the given path a Python package?"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        new[time] = latest[time] - old.get(time, 0)\n    return new<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles.<|file_separator|>", "l": true, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        new[time] = latest[time] - old.get(time, 0)\n    return new", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    for r in self.entries.itervalues():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    for r in self.entries.itervalues():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": true, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def text(self) -> str:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self) -> str:\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": true, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a MasterLocustRunner instance for this Environment\n\nArguments:\nmaster_bind_host: Interface/host that the master should use for incoming worker connections. \n                  Defaults to \"*\" which means all interfaces.\nmaster_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a MasterLocustRunner instance for this Environment\n\nArguments:\nmaster_bind_host: Interface/host that the master should use for incoming worker connections. \n                  Defaults to \"*\" which means all interfaces.\nmaster_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            for client in self.clients.all:\n            logger.debug(\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        for client in self.clients.all:\n            logger.debug(\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def _construct_basic_auth_str(username, password):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(username, str):\n        username = username.encode('latin1')\n    if isinstance(password, str):\n        password = password.encode('latin1')\n    return 'Basic ' + b64encode(b':'.join((username, password))).strip().decode(\"ascii\")<|fim_middle|>Construct Authorization header value to be used in HTTP Basic Auth<|file_separator|>", "l": true, "c": "def _construct_basic_auth_str(username, password):\n    if isinstance(username, str):\n        username = username.encode('latin1')\n    if isinstance(password, str):\n        password = password.encode('latin1')\n    return 'Basic ' + b64encode(b':'.join((username, password))).strip().decode(\"ascii\")", "d": "Construct Authorization header value to be used in HTTP Basic Auth"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": true, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def is_user_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": true, "c": "def is_user_class(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n    self.state = new_state<|fim_middle|>Updates the current state<|file_separator|>", "l": true, "c": "def update_state(self, new_state):\n    logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n    self.state = new_state", "d": "Updates the current state"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def on_request_success(method, path, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request_success(method, path, response_time, response_length):\n    stats[\"content-length\"] += response_length", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n        response=self,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n        response=self,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptLocust is raised inside a SubLocust,\nthe parent Locust whould immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptLocust is raised inside a SubLocust,\nthe parent Locust whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(2)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(base_filepath):\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(2)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def put(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"PUT\", path, payload=data, **kwargs)<|fim_middle|>Sends a PUT request<|file_separator|>", "l": true, "c": "def put(self, path, data=None, **kwargs):\n    return self.request(\"PUT\", path, payload=data, **kwargs)", "d": "Sends a PUT request"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a WorkerLocustRunner instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a WorkerLocustRunner instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def failures_csv(stats, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats, csv_writer):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def on_request_success(method, path, response_time, response):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += int(response.info.getheader(\"content-length\"))<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request_success(method, path, response_time, response):\n    stats[\"content-length\"] += int(response.info.getheader(\"content-length\"))", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def status_code(self) -> int:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": true, "c": "def status_code(self) -> int:\n    return self._response is not None and self._response.get_code() or 0", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": true, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master.<|file_separator|>", "l": true, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master."}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": true, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.<|file_separator|>", "l": true, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": true, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL<|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>        def _download_csv_response(csv_data, filename_prefix):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n                response = make_response(csv_data)\n            file_name = \"{0}_{1}.csv\".format(filename_prefix, time())\n            disposition = \"attachment;filename={0}\".format(file_name)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = disposition\n            return response<|fim_middle|>Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp.<|file_separator|>", "l": true, "c": "        def _download_csv_response(csv_data, filename_prefix):\n            response = make_response(csv_data)\n            file_name = \"{0}_{1}.csv\".format(filename_prefix, time())\n            disposition = \"attachment;filename={0}\".format(file_name)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = disposition\n            return response", "d": "Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL<|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL"}, {"e": "<|fim_prefix|>def patch(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"PATCH\", path, payload=data, **kwargs)<|fim_middle|>Sends a POST request<|file_separator|>", "l": true, "c": "def patch(self, path, data=None, **kwargs):\n    return self.request(\"PATCH\", path, payload=data, **kwargs)", "d": "Sends a POST request"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": true, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a WebUI instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a WebUI instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment, locust_classes):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment, locust_classes)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment, locust_classes):\n        super(LocalLocustRunner, self).__init__(environment, locust_classes)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = RequestStats(\"GET\", \"test\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = RequestStats.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = RequestStats.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": true, "c": "def test_serialize_through_message(self):\n    s1 = RequestStats(\"GET\", \"test\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = RequestStats.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = RequestStats.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.iterkeys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.iterkeys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def context(self) -> Dict:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return {}<|fim_middle|>Returns user specific context. Override this method to customize data to be forwarded in request event.\n\n:return: Context data\n:rtype: Dict<|file_separator|>", "l": true, "c": "    def context(self) -> Dict:\n        return {}", "d": "Returns user specific context. Override this method to customize data to be forwarded in request event.\n\n:return: Context data\n:rtype: Dict"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by killing all running locusts<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by killing all running locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def post(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"POST\", path, payload=data, **kwargs)<|fim_middle|>Sends a POST request<|file_separator|>", "l": true, "c": "def post(self, path, data=None, **kwargs):\n    return self.request(\"POST\", path, payload=data, **kwargs)", "d": "Sends a POST request"}, {"e": "<|fim_prefix|>def strictExp(min_wait,max_wait,mu=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        x = random.expovariate(mu)\n        increment = (max_wait-min_wait)/(mu*6.0)\n        result = min_wait + (x*increment)\n        if result<max_wait:\n            break\n    return result<|fim_middle|>Returns an exponentially distributed time strictly between two bounds.<|file_separator|>", "l": true, "c": "def strictExp(min_wait,max_wait,mu=1):\n    while True:\n        x = random.expovariate(mu)\n        increment = (max_wait-min_wait)/(mu*6.0)\n        result = min_wait + (x*increment)\n        if result<max_wait:\n            break\n    return result", "d": "Returns an exponentially distributed time strictly between two bounds."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.users)<|fim_middle|>:returns: Number of currently running users<|file_separator|>", "l": true, "c": "def user_count(self):\n    return len(self.users)", "d": ":returns: Number of currently running users"}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.locusts)<|fim_middle|>:returns: Number of currently running locust users<|file_separator|>", "l": true, "c": "def user_count(self):\n    return len(self.locusts)", "d": ":returns: Number of currently running locust users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles.<|file_separator|>", "l": true, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": true, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": true, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += stats[\"content-length\"]<|fim_middle|>This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": true, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += stats[\"content-length\"]", "d": "This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.users:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.users:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": true, "c": "def schedule_task(self, task_callable, first=False):\n    if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    stats[\"content-length\"] += data[\"content-length\"]<|fim_middle|>This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": true, "c": "def on_slave_report(client_id, data):\n    global stats\n    stats[\"content-length\"] += data[\"content-length\"]", "d": "This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def get_run_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return time.monotonic() - self.start_time<|fim_middle|>Calculates run time in seconds of the load test<|file_separator|>", "l": true, "c": "def get_run_time(self):\n    return time.monotonic() - self.start_time", "d": "Calculates run time in seconds of the load test"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def _urlopen(self, request):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        client = self.clientpool.get_client(request.url_split)\n    resp = client.request(request.method, request.url_split.request_uri,\n                          body=request.payload, headers=request.headers)\n    return self.response_type(resp, request=request, sent_request=resp._sent_request)<|fim_middle|>Override _urlopen() in order to make it use the response_type attribute<|file_separator|>", "l": true, "c": "def _urlopen(self, request):\n    client = self.clientpool.get_client(request.url_split)\n    resp = client.request(request.method, request.url_split.request_uri,\n                          body=request.payload, headers=request.headers)\n    return self.response_type(resp, request=request, sent_request=resp._sent_request)", "d": "Override _urlopen() in order to make it use the response_type attribute"}, {"e": "<|fim_prefix|>def on_request_success(request_type, name, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    stats[\"content-length\"] += response_length<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request_success(request_type, name, response_time, response_length):\n    global stats\n    stats[\"content-length\"] += response_length", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += stats[\"content-length\"]<|fim_middle|>This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": true, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += stats[\"content-length\"]", "d": "This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_environment(user_classes, shape_class, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, shape_class, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def auth_required_if_enabled(self, view_func):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            @wraps(view_func)\n        def wrapper(*args, **kwargs):\n            if self.app.config[\"BASIC_AUTH_ENABLED\"]:\n                if self.auth.authenticate():\n                    return view_func(*args, **kwargs)\n                else:\n                    return self.auth.challenge()\n            else:\n                return view_func(*args, **kwargs)\n\n        return wrapper<|fim_middle|>Decorator that can be used on custom route methods that will turn on Basic Auth \nauthentication if the ``--web-auth`` flag is used. Example::\n\n    @web_ui.app.route(\"/my_custom_route\")\n    @web_ui.auth_required_if_enabled\n    def my_custom_route():\n        return \"custom response\"<|file_separator|>", "l": true, "c": "    def auth_required_if_enabled(self, view_func):\n        @wraps(view_func)\n        def wrapper(*args, **kwargs):\n            if self.app.config[\"BASIC_AUTH_ENABLED\"]:\n                if self.auth.authenticate():\n                    return view_func(*args, **kwargs)\n                else:\n                    return self.auth.challenge()\n            else:\n                return view_func(*args, **kwargs)\n\n        return wrapper", "d": "Decorator that can be used on custom route methods that will turn on Basic Auth \nauthentication if the ``--web-auth`` flag is used. Example::\n\n    @web_ui.app.route(\"/my_custom_route\")\n    @web_ui.auth_required_if_enabled\n    def my_custom_route():\n        return \"custom response\""}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": true, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.raw = HTTPResponse()\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.raw = HTTPResponse()\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": true, "c": "def schedule_task(self, task_callable, first=False):\n    if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def reset_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.monotonic()<|fim_middle|>Resets start time back to 0<|file_separator|>", "l": true, "c": "def reset_time(self):\n    self.start_time = time.monotonic()", "d": "Resets start time back to 0"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": true, "c": "def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n    task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>This event is triggered on the worker instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the worker.<|file_separator|>", "l": true, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "This event is triggered on the worker instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the worker."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": true, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, num_clients=None, hatch_rate=None, step_clients=None, step_time=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, num_clients=num_clients, hatch_rate=hatch_rate, step_clients=step_clients, step_time=step_time)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, num_clients=None, hatch_rate=None, step_clients=None, step_time=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, num_clients=num_clients, hatch_rate=hatch_rate, step_clients=step_clients, step_time=step_time)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": true, "c": "def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n    task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, headers=None, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers=None, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(base_filepath):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def on_request_success(request_type, name, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request_success(request_type, name, response_time, response_length):\n    stats[\"content-length\"] += response_length", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def post(self, path, data, headers=None, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers=None, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failures_csv(stats, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats, csv_writer):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the\nlast X seconds, which in turn is used to calculate the current response time\npercentiles.<|file_separator|>", "l": true, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the\nlast X seconds, which in turn is used to calculate the current response time\npercentiles."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by killing all running locusts<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by killing all running locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a MasterLocustRunner instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a MasterLocustRunner instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history() + \"\\n\")<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history() + \"\\n\")", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats.setdefault(name, {\"content-length\": 0})\n    stats[name][\"content-length\"] += response_length<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n    stats.setdefault(name, {\"content-length\": 0})\n    stats[name][\"content-length\"] += response_length", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_requests.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_distribution.csv', 'w') as f:\n        f.write(distribution_csv())<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_requests.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_distribution.csv', 'w') as f:\n        f.write(distribution_csv())", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *tasks* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": true, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *tasks* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def greenlet_exception_logger(logger, level=logging.CRITICAL):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n        global unhandled_greenlet_exception\n        unhandled_greenlet_exception = True\n    return exception_handler<|fim_middle|>Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger.<|file_separator|>", "l": true, "c": "def greenlet_exception_logger(logger, level=logging.CRITICAL):\n    def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n        global unhandled_greenlet_exception\n        unhandled_greenlet_exception = True\n    return exception_handler", "d": "Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger."}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_reqs * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_reqs - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Percent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_reqs * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_reqs - processed_count) <= num_of_request):\n                return response_time", "d": "Percent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def get_run_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return round(time.monotonic() - self.start_time)<|fim_middle|>Calculates run time in seconds of the load test<|file_separator|>", "l": true, "c": "def get_run_time(self):\n    return round(time.monotonic() - self.start_time)", "d": "Calculates run time in seconds of the load test"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self) -> str:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self) -> str:\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": true, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def is_user_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(inspect.isclass(item) and issubclass(item, User) and item.abstract == False)<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": true, "c": "def is_user_class(item):\n    return bool(inspect.isclass(item) and issubclass(item, User) and item.abstract == False)", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": true, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>We override status_code in order to return None if bo valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": true, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "We override status_code in order to return None if bo valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": true, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": true, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a WorkerLocustRunner instance for this Environment\n\nArguments:\nmaster_host: Host/IP of a running master node\nmaster_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a WorkerLocustRunner instance for this Environment\n\nArguments:\nmaster_host: Host/IP of a running master node\nmaster_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(f\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(f\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": true, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        master_host=options.master_host,\n        master_port=options.master_port,\n        master_bind_host=options.master_bind_host,\n        master_bind_port=options.master_bind_port,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        master_host=options.master_host,\n        master_port=options.master_port,\n        master_bind_host=options.master_bind_host,\n        master_bind_port=options.master_bind_port,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            for client in self.clients.all:\n            logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        for client in self.clients.all:\n            logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": true, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Updating state to '%s', old state was '%s'\" % (new_state, self.state))\n    self.state = new_state<|fim_middle|>Updates the current state<|file_separator|>", "l": true, "c": "def update_state(self, new_state):\n    logger.debug(\"Updating state to '%s', old state was '%s'\" % (new_state, self.state))\n    self.state = new_state", "d": "Updates the current state"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def run_user(user):\n        \"\"\"\n        Main function for User greenlet. It's important that this function takes the user\n        instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n        User instance.\n        \"\"\"\n        user.run()\n    self._greenlet = gevent_group.spawn(run_user, self)\n    return self._greenlet<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": true, "c": "def start(self, gevent_group):\n    def run_user(user):\n        \"\"\"\n        Main function for User greenlet. It's important that this function takes the user\n        instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n        User instance.\n        \"\"\"\n        user.run()\n    self._greenlet = gevent_group.spawn(run_user, self)\n    return self._greenlet", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def greenlet_exception_logger(logger, level=logging.CRITICAL):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n    return exception_handler<|fim_middle|>Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger.<|file_separator|>", "l": true, "c": "def greenlet_exception_logger(logger, level=logging.CRITICAL):\n    def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n    return exception_handler", "d": "Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.locusts)<|fim_middle|>:returns: Number of currently running locust users<|file_separator|>", "l": true, "c": "def user_count(self):\n    return len(self.locusts)", "d": ":returns: Number of currently running locust users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def requests_csv(self, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        csv_writer.writerow(self.requests_csv_columns)\n    self._requests_data_rows(csv_writer)<|fim_middle|>Write requests csv with header and data rows.<|file_separator|>", "l": true, "c": "def requests_csv(self, csv_writer):\n    csv_writer.writerow(self.requests_csv_columns)\n    self._requests_data_rows(csv_writer)", "d": "Write requests csv with header and data rows."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n        \n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n        \n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": true, "c": "def on_report_to_master(client_id, data):\n    global stats\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": true, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, with_response_data=False, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    response = client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, with_response_data=False, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    response = client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_stats.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        if runners.locust_runner is not None:\n            runners.locust_runner.quit()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        if runners.locust_runner is not None:\n            runners.locust_runner.quit()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>        def _download_csv_response(csv_data, filename_prefix):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n                response = make_response(csv_data)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = f\"attachment;filename={_download_csv_suggest_file_name(filename_prefix)}\"\n            return response<|fim_middle|>Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp.<|file_separator|>", "l": true, "c": "        def _download_csv_response(csv_data, filename_prefix):\n            response = make_response(csv_data)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = f\"attachment;filename={_download_csv_suggest_file_name(filename_prefix)}\"\n            return response", "d": "Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>    def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if first:\n            self._task_queue.insert(0, task_callable)\n        else:\n            self._task_queue.append(task_callable)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": true, "c": "    def schedule_task(self, task_callable, first=False):\n        if first:\n            self._task_queue.insert(0, task_callable)\n        else:\n            self._task_queue.append(task_callable)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": true, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def get_readable_percentiles(percentile_list):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return [f\"{int(percentile * 100) if (percentile * 100).is_integer() else round(100 * percentile, 6)}%\"\n            for percentile in percentile_list]<|fim_middle|>Converts a list of percentiles from 0-1 fraction to 0%-100% view for using in console & csv reporting\n:param percentile_list: The list of percentiles in range 0-1\n:return: The list of string representation for each percentile in 0%-100% view<|file_separator|>", "l": true, "c": "def get_readable_percentiles(percentile_list):\n    return [f\"{int(percentile * 100) if (percentile * 100).is_integer() else round(100 * percentile, 6)}%\"\n            for percentile in percentile_list]", "d": "Converts a list of percentiles from 0-1 fraction to 0%-100% view for using in console & csv reporting\n:param percentile_list: The list of percentiles in range 0-1\n:return: The list of string representation for each percentile in 0%-100% view"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": true, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += data[\"content-length\"]<|fim_middle|>This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": true, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += data[\"content-length\"]", "d": "This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.users])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.users])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.<|file_separator|>", "l": true, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get_current_user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._runner.user_count<|fim_middle|>Returns current actual number of users from the runner<|file_separator|>", "l": true, "c": "def get_current_user_count(self):\n    return self._runner.user_count", "d": "Returns current actual number of users from the runner"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, use_response_times_cache=self.use_response_times_cache)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": true, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, use_response_times_cache=self.use_response_times_cache)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": true, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        marks=options.marks,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        marks=options.marks,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return self.client.urlopen(url, method=method, **kwargs)\n    except FAILURE_EXCEPTIONS as e:\n        if hasattr(e, \"response\"):\n            r = e.response\n        else:\n            r = ErrorResponse()\n        r.error = e\n        return r<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to either \nconnection problems, or invalid HTTP status codes<|file_separator|>", "l": true, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return self.client.urlopen(url, method=method, **kwargs)\n    except FAILURE_EXCEPTIONS as e:\n        if hasattr(e, \"response\"):\n            r = e.response\n        else:\n            r = ErrorResponse()\n        r.error = e\n        return r", "d": "Send an HTTP request, and catch any exception that might occur due to either \nconnection problems, or invalid HTTP status codes"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": true, "c": "    def start(self, gevent_group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": true, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in self.entries.itervalues():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in self.entries.itervalues():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master.<|file_separator|>", "l": true, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master."}, {"e": "<|fim_prefix|>def wait_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.user.wait_time:\n        return self.user.wait_time()\n    elif self.min_wait is not None and self.max_wait is not None:\n        return random.randint(self.min_wait, self.max_wait) / 1000.0\n    else:\n        raise MissingWaitTimeError(\"You must define a wait_time method on either the %s or %s class\" % (\n            type(self.user).__name__,\n            type(self).__name__,\n        ))<|fim_middle|>Method that returns the time (in seconds) between the execution of tasks. \n\nExample::\n\n    from locust import TaskSet, between\n    class Tasks(TaskSet):\n        wait_time = between(3, 25)<|file_separator|>", "l": true, "c": "def wait_time(self):\n    if self.user.wait_time:\n        return self.user.wait_time()\n    elif self.min_wait is not None and self.max_wait is not None:\n        return random.randint(self.min_wait, self.max_wait) / 1000.0\n    else:\n        raise MissingWaitTimeError(\"You must define a wait_time method on either the %s or %s class\" % (\n            type(self.user).__name__,\n            type(self).__name__,\n        ))", "d": "Method that returns the time (in seconds) between the execution of tasks. \n\nExample::\n\n    from locust import TaskSet, between\n    class Tasks(TaskSet):\n        wait_time = between(3, 25)"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": true, "c": "def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n    stats[\"content-length\"] += response_length", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, with_response_data=False, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, with_response_data=False, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a WebUI instance for this Environment and start running the web server\n\nArguments:\nhost: Host/interface that the web server should accept connections to. Defaults to \"*\"\n      which means all interfaces\nport: Port that the web server should listen to\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a WebUI instance for this Environment and start running the web server\n\nArguments:\nhost: Host/interface that the web server should accept connections to. Defaults to \"*\"\n      which means all interfaces\nport: Port that the web server should listen to\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_web_ui(self, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a WebUI instance for this Environment\n\nArguments:\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, auth_credentials=None):\n    self.web_ui = WebUI(self, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a WebUI instance for this Environment\n\nArguments:\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def aggregated_stats(self, name=\"Total\", full_request_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        total = StatsEntry(self, name, method=None)\n    for r in self.entries.itervalues():\n        total.extend(r, full_request_history=full_request_history)\n    return total<|fim_middle|>Returns a StatsEntry which is an aggregate of all stats entries \nwithin entries.<|file_separator|>", "l": true, "c": "def aggregated_stats(self, name=\"Total\", full_request_history=False):\n    total = StatsEntry(self, name, method=None)\n    for r in self.entries.itervalues():\n        total.extend(r, full_request_history=full_request_history)\n    return total", "d": "Returns a StatsEntry which is an aggregate of all stats entries \nwithin entries."}, {"e": "<|fim_prefix|>    def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": true, "c": "    def start(self, gevent_group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        exc,\n        self,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        exc,\n        self,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def filter_tasks_by_tags(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.include_tags is not None:\n            self.include_tags = set(self.include_tags)\n        if self.exclude_tags is not None:\n            self.exclude_tags = set(self.exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, self.include_tags, self.exclude_tags)<|fim_middle|>Filter the tasks on all the user_classes recursively, according to the include_tags and\nexclude_tags attributes<|file_separator|>", "l": true, "c": "    def filter_tasks_by_tags(self):\n        if self.include_tags is not None:\n            self.include_tags = set(self.include_tags)\n        if self.exclude_tags is not None:\n            self.exclude_tags = set(self.exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, self.include_tags, self.exclude_tags)", "d": "Filter the tasks on all the user_classes recursively, according to the include_tags and\nexclude_tags attributes"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.state == new_state:\n            return\n\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n        self.state = new_state<|fim_middle|>Updates the current state<|file_separator|>", "l": true, "c": "    def update_state(self, new_state):\n        if self.state == new_state:\n            return\n\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n        self.state = new_state", "d": "Updates the current state"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple(int, float)]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple(int, float)]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": true, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": true, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def stop(self, force=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False<|fim_middle|>Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False<|file_separator|>", "l": true, "c": "    def stop(self, force=False):\n        if force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False", "d": "Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, tls_cert=None, tls_key=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, tls_cert=tls_cert, tls_key=tls_key)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, tls_cert=None, tls_key=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, tls_cert=tls_cert, tls_key=tls_key)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def status_code(self) -> int:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": true, "c": "def status_code(self) -> int:\n    return self._response is not None and self._response.get_code() or 0", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": true, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return (0, 0, True)<|fim_middle|>Returns a tuple with 3 elements to control the running load test.\n\n    user_count: Total user count\n    hatch_rate: Hatch rate to use when changing total user count\n    stop_test: A boolean to stop the test<|file_separator|>", "l": true, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return (0, 0, True)", "d": "Returns a tuple with 3 elements to control the running load test.\n\n    user_count: Total user count\n    hatch_rate: Hatch rate to use when changing total user count\n    stop_test: A boolean to stop the test"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def start(self, group: Group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = group.spawn(run_user, self)\n        self._group = group\n        return self._greenlet<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": true, "c": "    def start(self, group: Group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = group.spawn(run_user, self)\n        self._group = group\n        return self._greenlet", "d": "Start a greenlet that runs this User instance.\n\n:param group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": true, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": true, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_environment(user_classes, shaper_class, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shaper_class=shaper_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, shaper_class, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        shaper_class=shaper_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": true, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": true, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": true, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": true, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(base_filepath):\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_history_csv_header():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'<|fim_middle|>Headers for the stats history CSV<|file_separator|>", "l": true, "c": "def stats_history_csv_header():\n    return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'", "d": "Headers for the stats history CSV"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": true, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Reference to the :py:attr:`client <locust.core.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": true, "c": "def client(self):\n    return self.user.client", "d": "Reference to the :py:attr:`client <locust.core.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": true, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": true, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": true, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": true, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": true, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": true, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": true, "c": "def get(self, path, headers={}, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>    def apply_tags(self, include_tags=None, exclude_tags=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if include_tags is not None:\n            include_tags = set(include_tags)\n        if exclude_tags is not None:\n            exclude_tags = set(exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, include_tags, exclude_tags)<|fim_middle|>Filter the tasks on all the user_classes recursively, according to the tag options\n\n:param include_tags: If set, the runner will only run tasks that are tagged by tags in this list\n:param exclude_tags: If set, the runner will only run tasks that aren't tagged by tags in this list<|file_separator|>", "l": true, "c": "    def apply_tags(self, include_tags=None, exclude_tags=None):\n        if include_tags is not None:\n            include_tags = set(include_tags)\n        if exclude_tags is not None:\n            exclude_tags = set(exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, include_tags, exclude_tags)", "d": "Filter the tasks on all the user_classes recursively, according to the tag options\n\n:param include_tags: If set, the runner will only run tasks that are tagged by tags in this list\n:param exclude_tags: If set, the runner will only run tasks that aren't tagged by tags in this list"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": true, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = str(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = str(self.content, errors='replace')\n    return content<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": true, "c": "def text(self):\n    try:\n        content = str(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = str(self.content, errors='replace')\n    return content", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def stop(self, force=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self._greenlet is greenlet.getcurrent():\n\n            self._group.killone(self._greenlet, block=False)\n            return True\n        elif force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False<|fim_middle|>Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False<|file_separator|>", "l": true, "c": "    def stop(self, force=False):\n        if self._greenlet is greenlet.getcurrent():\n\n            self._group.killone(self._greenlet, block=False)\n            return True\n        elif force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False", "d": "Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": true, "c": "def success(self):\n    self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": true, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return (0, 0, True)<|fim_middle|>Returns a tuple with 3 elements to control the running load test.\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n    stop_test -- A boolean to stop the test<|file_separator|>", "l": true, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return (0, 0, True)", "d": "Returns a tuple with 3 elements to control the running load test.\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n    stop_test -- A boolean to stop the test"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": true, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": true, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)<|fim_middle|>Create a LocalLocustRunner instance for this Environment<|file_separator|>", "l": true, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)", "d": "Create a LocalLocustRunner instance for this Environment"}, {"e": "<|fim_prefix|>def is_shape_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, LoadTestShape)\n        and item.__dict__['__module__'] != 'locust.shape'\n    )<|fim_middle|>Check if a class is a LoadTestShape<|file_separator|>", "l": true, "c": "def is_shape_class(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, LoadTestShape)\n        and item.__dict__['__module__'] != 'locust.shape'\n    )", "d": "Check if a class is a LoadTestShape"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": true, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": true, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": true, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": true, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": true, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": true, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": true, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": true, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": true, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": true, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if((num_requests - processed_count) <= num_of_request):\n            return response_time<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": true, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if((num_requests - processed_count) <= num_of_request):\n            return response_time", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": true, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": true, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def stats_history_csv_header():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'<|fim_middle|>Headers for the stats history CSV<|file_separator|>", "l": true, "c": "def stats_history_csv_header():\n    return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'", "d": "Headers for the stats history CSV"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": true, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": true, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def _is_package(path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return (\n        os.path.isdir(path)\n        and os.path.exists(os.path.join(path, '__init__.py'))\n    )<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def _is_package(path):\n    return (\n        os.path.isdir(path)\n        and os.path.exists(os.path.join(path, '__init__.py'))\n    )", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def success(self):\n    self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        new[time] = latest[time] - old.get(time, 0)\n    return new<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        new[time] = latest[time] - old.get(time, 0)\n    return new", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    for r in self.entries.itervalues():\n        r.reset()<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    for r in self.entries.itervalues():\n        r.reset()", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>This event is triggered on the worker instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the worker.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "This event is triggered on the worker instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the worker."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Converts a list of percentiles from 0-1 fraction to 0%-100% view for using in console & csv reporting\n:param percentile_list: The list of percentiles in range 0-1\n:return: The list of string representation for each percentile in 0%-100% view<|file_separator|>", "l": false, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Converts a list of percentiles from 0-1 fraction to 0%-100% view for using in console & csv reporting\n:param percentile_list: The list of percentiles in range 0-1\n:return: The list of string representation for each percentile in 0%-100% view"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Check if a class is a LoadTestShape<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Check if a class is a LoadTestShape"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def text(self) -> str:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def text(self) -> str:\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Returns a tuple with 3 elements to control the running load test.\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n    stop_test -- A boolean to stop the test<|file_separator|>", "l": false, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Returns a tuple with 3 elements to control the running load test.\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n    stop_test -- A boolean to stop the test"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            for client in self.clients.all:\n            logger.debug(\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        for client in self.clients.all:\n            logger.debug(\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def _construct_basic_auth_str(username, password):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(username, str):\n        username = username.encode('latin1')\n    if isinstance(password, str):\n        password = password.encode('latin1')\n    return 'Basic ' + b64encode(b':'.join((username, password))).strip().decode(\"ascii\")<|fim_middle|>Is the given path a Python package?<|file_separator|>", "l": false, "c": "def _construct_basic_auth_str(username, password):\n    if isinstance(username, str):\n        username = username.encode('latin1')\n    if isinstance(password, str):\n        password = password.encode('latin1')\n    return 'Basic ' + b64encode(b':'.join((username, password))).strip().decode(\"ascii\")", "d": "Is the given path a Python package?"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Resets start time back to 0<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Resets start time back to 0"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def is_user_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def is_user_class(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>We override status_code in order to return None if bo valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "We override status_code in order to return None if bo valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n    self.state = new_state<|fim_middle|>:returns: Number of currently running locust users<|file_separator|>", "l": false, "c": "def update_state(self, new_state):\n    logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n    self.state = new_state", "d": ":returns: Number of currently running locust users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def on_request_success(method, path, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def on_request_success(method, path, response_time, response_length):\n    stats[\"content-length\"] += response_length", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n        response=self,\n    )\n    self._is_reported = True<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n        response=self,\n    )\n    self._is_reported = True", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()<|fim_middle|>Updates the current state<|file_separator|>", "l": false, "c": "def stop(self):\n    logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()", "d": "Updates the current state"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(2)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def stats_writer(base_filepath):\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(2)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def put(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"PUT\", path, payload=data, **kwargs)<|fim_middle|>Filter the tasks on all the user_classes recursively, according to the tag options\n\n:param include_tags: If set, the runner will only run tasks that are tagged by tags in this list\n:param exclude_tags: If set, the runner will only run tasks that aren't tagged by tags in this list<|file_separator|>", "l": false, "c": "def put(self, path, data=None, **kwargs):\n    return self.request(\"PUT\", path, payload=data, **kwargs)", "d": "Filter the tasks on all the user_classes recursively, according to the tag options\n\n:param include_tags: If set, the runner will only run tasks that are tagged by tags in this list\n:param exclude_tags: If set, the runner will only run tasks that aren't tagged by tags in this list"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def failures_csv(stats, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def failures_csv(stats, csv_writer):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = unicode(self.content, errors='replace')\n    return content", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def on_request_success(method, path, response_time, response):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += int(response.info.getheader(\"content-length\"))<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": false, "c": "def on_request_success(method, path, response_time, response):\n    stats[\"content-length\"] += int(response.info.getheader(\"content-length\"))", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Calculates run time in seconds of the load test<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Calculates run time in seconds of the load test"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": false, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by killing all running locusts<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by killing all running locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def status_code(self) -> int:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def status_code(self) -> int:\n    return self._response is not None and self._response.get_code() or 0", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n        \n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n        \n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>        def _download_csv_response(csv_data, filename_prefix):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n                response = make_response(csv_data)\n            file_name = \"{0}_{1}.csv\".format(filename_prefix, time())\n            disposition = \"attachment;filename={0}\".format(file_name)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = disposition\n            return response<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "        def _download_csv_response(csv_data, filename_prefix):\n            response = make_response(csv_data)\n            file_name = \"{0}_{1}.csv\".format(filename_prefix, time())\n            disposition = \"attachment;filename={0}\".format(file_name)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = disposition\n            return response", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def patch(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"PATCH\", path, payload=data, **kwargs)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def patch(self, path, data=None, **kwargs):\n    return self.request(\"PATCH\", path, payload=data, **kwargs)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Creates a WebUI instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Creates a WebUI instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>    def __init__(self, environment, locust_classes):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment, locust_classes)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "    def __init__(self, environment, locust_classes):\n        super(LocalLocustRunner, self).__init__(environment, locust_classes)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return None<|fim_middle|>Filter the tasks on all the user_classes recursively, according to the include_tags and\nexclude_tags attributes<|file_separator|>", "l": false, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return None", "d": "Filter the tasks on all the user_classes recursively, according to the include_tags and\nexclude_tags attributes"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def write_csv_files(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Headers for the stats history CSV<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Headers for the stats history CSV"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp.<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Generate csv file download response with 'csv_data'.\n\nArguments:\ncsv_data: CSV header and data rows.\nfilename_prefix: Prefix of the filename to suggest for saving the download. Will be appended with timestamp."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = RequestStats(\"GET\", \"test\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = RequestStats.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = RequestStats.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "def test_serialize_through_message(self):\n    s1 = RequestStats(\"GET\", \"test\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = RequestStats.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = RequestStats.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.iterkeys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.iterkeys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the slave nodes this will be the sum of the content-lengths since the \nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "def success(self):\n    self._manual_result = True", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>    def context(self) -> Dict:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return {}<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def context(self) -> Dict:\n        return {}", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def success(self):\n    self.locust_environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Updates the current state<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Updates the current state"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Sends a POST request<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Sends a POST request"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def post(self, path, data=None, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.request(\"POST\", path, payload=data, **kwargs)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def post(self, path, data=None, **kwargs):\n    return self.request(\"POST\", path, payload=data, **kwargs)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def strictExp(min_wait,max_wait,mu=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        x = random.expovariate(mu)\n        increment = (max_wait-min_wait)/(mu*6.0)\n        result = min_wait + (x*increment)\n        if result<max_wait:\n            break\n    return result<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def strictExp(min_wait,max_wait,mu=1):\n    while True:\n        x = random.expovariate(mu)\n        increment = (max_wait-min_wait)/(mu*6.0)\n        result = min_wait + (x*increment)\n        if result<max_wait:\n            break\n    return result", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger.<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger."}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Decorator that can be used on custom route methods that will turn on Basic Auth \nauthentication if the ``--web-auth`` flag is used. Example::\n\n    @web_ui.app.route(\"/my_custom_route\")\n    @web_ui.auth_required_if_enabled\n    def my_custom_route():\n        return \"custom response\"<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Decorator that can be used on custom route methods that will turn on Basic Auth \nauthentication if the ``--web-auth`` flag is used. Example::\n\n    @web_ui.app.route(\"/my_custom_route\")\n    @web_ui.auth_required_if_enabled\n    def my_custom_route():\n        return \"custom response\""}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.users)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def user_count(self):\n    return len(self.users)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.locusts)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def user_count(self):\n    return len(self.locusts)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop(self):\n    logger.debug(\"Stopping all users\")\n    self.update_state(STATE_CLEANUP)\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.update_state(STATE_STOPPED)\n    self.cpu_log_warning()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Create a WorkerLocustRunner instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Create a WorkerLocustRunner instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:returns: Number of currently running locust users<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": ":returns: Number of currently running locust users"}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Returns an exponentially distributed time strictly between two bounds.<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Returns an exponentially distributed time strictly between two bounds."}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *tasks* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *tasks* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": false, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += stats[\"content-length\"]<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += stats[\"content-length\"]", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.users:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.users:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": "This event is triggered on the master isntance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def success(self):\n    self._manual_result = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": false, "c": "def schedule_task(self, task_callable, first=False):\n    if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    stats[\"content-length\"] += data[\"content-length\"]<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def on_slave_report(client_id, data):\n    global stats\n    stats[\"content-length\"] += data[\"content-length\"]", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get_run_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return time.monotonic() - self.start_time<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def get_run_time(self):\n    return time.monotonic() - self.start_time", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def _urlopen(self, request):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        client = self.clientpool.get_client(request.url_split)\n    resp = client.request(request.method, request.url_split.request_uri,\n                          body=request.payload, headers=request.headers)\n    return self.response_type(resp, request=request, sent_request=resp._sent_request)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def _urlopen(self, request):\n    client = self.clientpool.get_client(request.url_split)\n    resp = client.request(request.method, request.url_split.request_uri,\n                          body=request.payload, headers=request.headers)\n    return self.response_type(resp, request=request, sent_request=resp._sent_request)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def on_request_success(request_type, name, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    stats[\"content-length\"] += response_length<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def on_request_success(request_type, name, response_time, response_length):\n    global stats\n    stats[\"content-length\"] += response_length", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def create_environment(user_classes, shape_class, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def create_environment(user_classes, shape_class, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def auth_required_if_enabled(self, view_func):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            @wraps(view_func)\n        def wrapper(*args, **kwargs):\n            if self.app.config[\"BASIC_AUTH_ENABLED\"]:\n                if self.auth.authenticate():\n                    return view_func(*args, **kwargs)\n                else:\n                    return self.auth.challenge()\n            else:\n                return view_func(*args, **kwargs)\n\n        return wrapper<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def auth_required_if_enabled(self, view_func):\n        @wraps(view_func)\n        def wrapper(*args, **kwargs):\n            if self.app.config[\"BASIC_AUTH_ENABLED\"]:\n                if self.auth.authenticate():\n                    return view_func(*args, **kwargs)\n                else:\n                    return self.auth.challenge()\n            else:\n                return view_func(*args, **kwargs)\n\n        return wrapper", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Create a WorkerLocustRunner instance for this Environment\n\nArguments:\nmaster_host: Host/IP of a running master node\nmaster_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Create a WorkerLocustRunner instance for this Environment\n\nArguments:\nmaster_host: Host/IP of a running master node\nmaster_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.raw = HTTPResponse()\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.raw = HTTPResponse()\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Override _urlopen() in order to make it use the response_type attribute<|file_separator|>", "l": false, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "Override _urlopen() in order to make it use the response_type attribute"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": false, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Stop a running load test by killing all running locusts<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Stop a running load test by killing all running locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Updates the current state<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Updates the current state"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "def schedule_task(self, task_callable, first=False):\n    if first:\n        self._task_queue.insert(0, task_callable)\n    else:\n        self._task_queue.append(task_callable)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Sends a POST request<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Sends a POST request"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def reset_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.monotonic()<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def reset_time(self):\n    self.start_time = time.monotonic()", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        content = unicode(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n    task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>Method that returns the time (in seconds) between the execution of tasks. \n\nExample::\n\n    from locust import TaskSet, between\n    class Tasks(TaskSet):\n        wait_time = between(3, 25)<|file_separator|>", "l": false, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": "Method that returns the time (in seconds) between the execution of tasks. \n\nExample::\n\n    from locust import TaskSet, between\n    class Tasks(TaskSet):\n        wait_time = between(3, 25)"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, num_clients=None, hatch_rate=None, step_clients=None, step_time=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, num_clients=num_clients, hatch_rate=hatch_rate, step_clients=step_clients, step_time=step_time)\n    return self.web_ui<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, num_clients=None, hatch_rate=None, step_clients=None, step_time=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, num_clients=num_clients, hatch_rate=hatch_rate, step_clients=step_clients, step_time=step_time)\n    return self.web_ui", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the\nlast X seconds, which in turn is used to calculate the current response time\npercentiles.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the\nlast X seconds, which in turn is used to calculate the current response time\npercentiles."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Calculates run time in seconds of the load test<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Calculates run time in seconds of the load test"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def schedule_task(self, task_callable, args=None, kwargs=None, first=False):\n    task = {\"callable\":task_callable, \"args\":args or [], \"kwargs\":kwargs or {}}\n    if first:\n        self._task_queue.insert(0, task)\n    else:\n        self._task_queue.append(task)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self._request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def get(self, path, headers=None, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def get(self, path, headers=None, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def stats_writer(base_filepath):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def on_request_success(request_type, name, response_time, response_length):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def on_request_success(request_type, name, response_time, response_length):\n    stats[\"content-length\"] += response_length", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def post(self, path, data, headers=None, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:returns: Number of currently running users<|file_separator|>", "l": false, "c": "def post(self, path, data, headers=None, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": ":returns: Number of currently running users"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def failures_csv(stats, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def failures_csv(stats, csv_writer):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    csv_writer.writerow([\n        \"Method\",\n        \"Name\",\n        \"Error\",\n        \"Occurrences\",\n    ])\n    for s in sort_stats(stats.errors):\n        csv_writer.writerow([\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ])", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def diff_response_time_dicts(latest, old):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def diff_response_time_dicts(latest, old):\n    new = {}\n    for time in latest:\n        diff = latest[time] - old.get(time, 0)\n        if diff:\n            new[time] = diff\n    return new", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.last_request_timestamp = None\n    self.start_time = None", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles.<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.kill_locust_instances([g.args[0] for g in self.locusts])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet would immediately reschedule another task."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Returns a tuple with 3 elements to control the running load test.\n\n    user_count: Total user count\n    hatch_rate: Hatch rate to use when changing total user count\n    stop_test: A boolean to stop the test<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Returns a tuple with 3 elements to control the running load test.\n\n    user_count: Total user count\n    hatch_rate: Hatch rate to use when changing total user count\n    stop_test: A boolean to stop the test"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return urljoin(self.base_url, path)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        locust_classes=self.locust_classes,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history() + \"\\n\")<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history() + \"\\n\")", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats.setdefault(name, {\"content-length\": 0})\n    stats[name][\"content-length\"] += response_length<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n    stats.setdefault(name, {\"content-length\": 0})\n    stats[name][\"content-length\"] += response_length", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def wait(self):\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        if self.user._state == LOCUST_STATE_STOPPING:\n            raise StopUser()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return super().request(method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Start a greenlet that runs this User instance.\n\n:param gevent_group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_requests.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_distribution.csv', 'w') as f:\n        f.write(distribution_csv())<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_requests.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_distribution.csv', 'w') as f:\n        f.write(distribution_csv())", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task."}, {"e": "<|fim_prefix|>def greenlet_exception_logger(logger, level=logging.CRITICAL):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n        global unhandled_greenlet_exception\n        unhandled_greenlet_exception = True\n    return exception_handler<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def greenlet_exception_logger(logger, level=logging.CRITICAL):\n    def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n        global unhandled_greenlet_exception\n        unhandled_greenlet_exception = True\n    return exception_handler", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_reqs * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_reqs - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_reqs * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_reqs - processed_count) <= num_of_request):\n                return response_time", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(self.num_clients)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(self.num_clients)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def get_run_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return round(time.monotonic() - self.start_time)<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": false, "c": "def get_run_time(self):\n    return round(time.monotonic() - self.start_time)", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def text(self) -> str:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def text(self) -> str:\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return str(self.content, self.encoding, errors='replace')", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>prepend url with hostname unless it's already an absolute URL<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "prepend url with hostname unless it's already an absolute URL"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def is_user_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(inspect.isclass(item) and issubclass(item, User) and item.abstract == False)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def is_user_class(item):\n    return bool(inspect.isclass(item) and issubclass(item, User) and item.abstract == False)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create a MasterLocustRunner instance for this Environment\n\nArguments:\nmaster_bind_host: Interface/host that the master should use for incoming worker connections. \n                  Defaults to \"*\" which means all interfaces.\nmaster_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create a MasterLocustRunner instance for this Environment\n\nArguments:\nmaster_bind_host: Interface/host that the master should use for incoming worker connections. \n                  Defaults to \"*\" which means all interfaces.\nmaster_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Returns user specific context. Override this method to customize data to be forwarded in request event.\n\n:return: Context data\n:rtype: Dict<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Returns user specific context. Override this method to customize data to be forwarded in request event.\n\n:return: Context data\n:rtype: Dict"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to either \nconnection problems, or invalid HTTP status codes<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Send an HTTP request, and catch any exception that might occur due to either \nconnection problems, or invalid HTTP status codes"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterLocustRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        include_tags=options.include_tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behavour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(f\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(f\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        master_host=options.master_host,\n        master_port=options.master_port,\n        master_bind_host=options.master_bind_host,\n        master_bind_port=options.master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        master_host=options.master_host,\n        master_port=options.master_port,\n        master_bind_host=options.master_bind_host,\n        master_bind_port=options.master_bind_port,\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            for client in self.clients.all:\n            logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>If *reschedule* is True and the InterruptLocust is raised inside a SubLocust,\nthe parent Locust whould immediately reschedule another task.<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        for client in self.clients.all:\n            logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n            self.server.send_to_client(Message(msg_type, data, client.id))", "d": "If *reschedule* is True and the InterruptLocust is raised inside a SubLocust,\nthe parent Locust whould immediately reschedule another task."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.num_requests = 0\n    self.num_failures = 0\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.last_request_timestamp = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed."}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Stop the user greenlet.\n\n:param force: If False (the default) the stopping is done gracefully by setting the state to LOCUST_STATE_STOPPING\n              which will make the User instance stop once any currently running task is complete and on_stop\n              methods are called. If force is True the greenlet will be killed immediately.\n:returns: True if the greenlet was killed immediately, otherwise False"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        logger.debug(\"Updating state to '%s', old state was '%s'\" % (new_state, self.state))\n    self.state = new_state<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def update_state(self, new_state):\n    logger.debug(\"Updating state to '%s', old state was '%s'\" % (new_state, self.state))\n    self.state = new_state", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content<|fim_middle|>We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        charset = self.headers.get('content-type', '').partition(\"charset=\")[2]\n        content = unicode(self.content, charset or 'utf-8', errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        if self.content is None:\n            content = None\n        else:\n            content = unicode(self.content, errors='replace')\n    return content", "d": "We override status_code in order to return None if no valid response was \nreturned. E.g. in the case of connection errors"}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def run_user(user):\n        \"\"\"\n        Main function for User greenlet. It's important that this function takes the user\n        instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n        User instance.\n        \"\"\"\n        user.run()\n    self._greenlet = gevent_group.spawn(run_user, self)\n    return self._greenlet<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def start(self, gevent_group):\n    def run_user(user):\n        \"\"\"\n        Main function for User greenlet. It's important that this function takes the user\n        instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n        User instance.\n        \"\"\"\n        user.run()\n    self._greenlet = gevent_group.spawn(run_user, self)\n    return self._greenlet", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy.<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Interrupt the TaskSet and hand over execution control back to the parent TaskSet.\n\nIf *reschedule* is True (default), the parent User will immediately re-schedule,\nand execute, a new task.\n\nThis method should not be called by the root TaskSet (the one that is immediately, \nattached to the User class's *task_set* attribute), but rather in nested TaskSet\nclasses further down the hierarchy."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def greenlet_exception_logger(logger, level=logging.CRITICAL):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n    return exception_handler<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def greenlet_exception_logger(logger, level=logging.CRITICAL):\n    def exception_handler(greenlet):\n        logger.log(level, \"Unhandled exception in greenlet: %s\", greenlet, exc_info=greenlet.exc_info)\n    return exception_handler", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return len(self.locusts)<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def user_count(self):\n    return len(self.locusts)", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>Construct Authorization header value to be used in HTTP Basic Auth<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": "Construct Authorization header value to be used in HTTP Basic Auth"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def success(self):\n    self.environment.events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Sends a PUT request<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Sends a PUT request"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Writes the requests and distribution csvs.<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Writes the requests and distribution csvs."}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}\n    self.history = []", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def requests_csv(self, csv_writer):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        csv_writer.writerow(self.requests_csv_columns)\n    self._requests_data_rows(csv_writer)<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def requests_csv(self, csv_writer):\n    csv_writer.writerow(self.requests_csv_columns)\n    self._requests_data_rows(csv_writer)", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    if self.encoding is None:\n        if self.headers is None:\n            self.encoding = 'utf-8'\n        else:\n            self.encoding = self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        global stats\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def on_report_to_master(client_id, data):\n    global stats\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._manual_result = True<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def success(self):\n    self._manual_result = True", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, with_response_data=False, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>Raise any connection errors that occurred during the request<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, with_response_data=False, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "Raise any connection errors that occurred during the request"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make the running user sleep for a duration defined by the User.wait_time\nfunction.\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task even if you've\nset a stop_timeout. If this behaviour is not desired, you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath):\n    with open(base_filepath + '_stats.csv', \"w\") as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_response_times.csv', 'w') as f:\n        f.write(distribution_csv())", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.locust_environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        if runners.locust_runner is not None:\n            runners.locust_runner.quit()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        if runners.locust_runner is not None:\n            runners.locust_runner.quit()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def __import_locustfile__(filename, path):\n    source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n    return  source.load_module()", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>        def _download_csv_response(csv_data, filename_prefix):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n                response = make_response(csv_data)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = f\"attachment;filename={_download_csv_suggest_file_name(filename_prefix)}\"\n            return response<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": false, "c": "        def _download_csv_response(csv_data, filename_prefix):\n            response = make_response(csv_data)\n            response.headers[\"Content-type\"] = \"text/csv\"\n            response.headers[\"Content-disposition\"] = f\"attachment;filename={_download_csv_suggest_file_name(filename_prefix)}\"\n            return response", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>    def schedule_task(self, task_callable, first=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if first:\n            self._task_queue.insert(0, task_callable)\n        else:\n            self._task_queue.append(task_callable)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def schedule_task(self, task_callable, first=False):\n        if first:\n            self._task_queue.insert(0, task_callable)\n        else:\n            self._task_queue.append(task_callable)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def on_report_to_master(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def on_report_to_master(client_id, data):\n    data[\"content-length\"] = stats[\"content-length\"]\n    stats[\"content-length\"] = 0", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return requests.Session.request(self, method, url, **kwargs)\n    except (MissingSchema, InvalidSchema, InvalidURL):\n        raise\n    except RequestException as e:\n        r = LocustResponse()\n        r.error = e\n        r.status_code = 0\n        r.request = Request(method, url).prepare()\n        return r", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    events.hatch_complete.fire(user_count=self.user_count)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def get_readable_percentiles(percentile_list):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return [f\"{int(percentile * 100) if (percentile * 100).is_integer() else round(100 * percentile, 6)}%\"\n            for percentile in percentile_list]<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def get_readable_percentiles(percentile_list):\n    return [f\"{int(percentile * 100) if (percentile * 100).is_integer() else round(100 * percentile, 6)}%\"\n            for percentile in percentile_list]", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def stats_writer(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def on_slave_report(client_id, data):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += data[\"content-length\"]<|fim_middle|>Headers for the stats history CSV<|file_separator|>", "l": false, "c": "def on_slave_report(client_id, data):\n    stats[\"content-length\"] += data[\"content-length\"]", "d": "Headers for the stats history CSV"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.users])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.users])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`LocalRunner <locust.runners.LocalRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.max_requests = None\n    self.start_time = None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def interrupt(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        raise InterruptTaskSet(reschedule)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def interrupt(self, reschedule=True):\n    raise InterruptTaskSet(reschedule)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    hatch_rate -- Hatch rate to use when changing total user count\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Creates a WebUI instance for this Environment\n\nArguments:\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Creates a WebUI instance for this Environment\n\nArguments:\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(stats, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n\n        print_error_report()\n        sys.exit(code)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Shut down locust by firing quitting event, printing/writing stats and exiting<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Shut down locust by firing quitting event, printing/writing stats and exiting"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def get_current_user_count(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._runner.user_count<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get_current_user_count(self):\n    return self._runner.user_count", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, use_response_times_cache=self.use_response_times_cache)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, use_response_times_cache=self.use_response_times_cache)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>Create a MasterLocustRunner instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "Create a MasterLocustRunner instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def get(self, path, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def get(self, path, name=None):\n    f = self.opener.open(self.base_url + path)\n    data = f.read()\n    f.close()\n    return data", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        marks=options.marks,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        marks=options.marks,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, User)\n        and item.abstract == False\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Percent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Percent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))<|fim_middle|>Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.runner.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.runner.stats))", "d": "Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def _send_request_safe_mode(self, method, url, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        return self.client.urlopen(url, method=method, **kwargs)\n    except FAILURE_EXCEPTIONS as e:\n        if hasattr(e, \"response\"):\n            r = e.response\n        else:\n            r = ErrorResponse()\n        r.error = e\n        return r<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "def _send_request_safe_mode(self, method, url, **kwargs):\n    try:\n        return self.client.urlopen(url, method=method, **kwargs)\n    except FAILURE_EXCEPTIONS as e:\n        if hasattr(e, \"response\"):\n            r = e.response\n        else:\n            r = ErrorResponse()\n        r.error = e\n        return r", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def success(self):\n    events.request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Create a :class:`MasterRunner <locust.runners.MasterRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>    def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def start(self, gevent_group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __import_locustfile__(filename, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def __import_locustfile__(filename, path):\n        try:\n\n            source = importlib.machinery.SourceFileLoader(os.path.splitext(locustfile)[0], path)\n            imported = source.load_module()\n        except AttributeError:\n\n            import imp\n            imported = imp.load_source(os.path.splitext(locustfile)[0], path)\n\n        return imported", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in self.entries.itervalues():\n        r.reset()<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in self.entries.itervalues():\n        r.reset()", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": "Sends a message to attached worker node(s)\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send\n:param client_id: Optional id of the target worker node.\n                    If None, will send to all attached workers"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def test_serialize_through_message(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def test_serialize_through_message(self):\n    s1 = StatsEntry(self.stats, \"test\", \"GET\")\n    s1.log(10, 0)\n    s1.log(20, 0)\n    s1.log(40, 0)\n    u1 = StatsEntry.unserialize(s1.serialize())\n\n    data = Message.unserialize(Message(\"dummy\", s1.serialize(), \"none\").serialize()).data\n    u1 = StatsEntry.unserialize(data)\n\n    self.assertEqual(20, u1.median_response_time)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def wait_time(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.user.wait_time:\n        return self.user.wait_time()\n    elif self.min_wait is not None and self.max_wait is not None:\n        return random.randint(self.min_wait, self.max_wait) / 1000.0\n    else:\n        raise MissingWaitTimeError(\"You must define a wait_time method on either the %s or %s class\" % (\n            type(self.user).__name__,\n            type(self).__name__,\n        ))<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def wait_time(self):\n    if self.user.wait_time:\n        return self.user.wait_time()\n    elif self.min_wait is not None and self.max_wait is not None:\n        return random.randint(self.min_wait, self.max_wait) / 1000.0\n    else:\n        raise MissingWaitTimeError(\"You must define a wait_time method on either the %s or %s class\" % (\n            type(self.user).__name__,\n            type(self).__name__,\n        ))", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def locust_init(environment, web_ui, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.<|file_separator|>", "l": false, "c": "def locust_init(environment, web_ui, **kwargs):\n    if web_ui:\n\n        @web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request."}, {"e": "<|fim_prefix|>def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        stats[\"content-length\"] += response_length<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):\n    stats[\"content-length\"] += response_length", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, with_response_data=False, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, with_response_data=False, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"*\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def create_web_ui(self, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Shut down locust by firing quitting event, printing stats and exiting<|file_separator|>", "l": false, "c": "def create_web_ui(self, auth_credentials=None):\n    self.web_ui = WebUI(self, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Shut down locust by firing quitting event, printing stats and exiting"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    response = client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.spawning_greenlet and not self.spawning_greenlet.ready():\n        self.spawning_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nReturns an HttpResponse instance, or None if the request failed.\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    response = client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master.<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    write_stats_history_csv_header(base_filepath)\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def aggregated_stats(self, name=\"Total\", full_request_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        total = StatsEntry(self, name, method=None)\n    for r in self.entries.itervalues():\n        total.extend(r, full_request_history=full_request_history)\n    return total<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def aggregated_stats(self, name=\"Total\", full_request_history=False):\n    total = StatsEntry(self, name, method=None)\n    for r in self.entries.itervalues():\n        total.extend(r, full_request_history=full_request_history)\n    return total", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def start(self, gevent_group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def start(self, gevent_group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = gevent_group.spawn(run_user, self)\n        return self._greenlet", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        exc,\n        self,\n    )\n    self._is_reported = True<|fim_middle|>Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        self.locust_request_meta[\"method\"],\n        self.locust_request_meta[\"name\"],\n        self.locust_request_meta[\"response_time\"],\n        exc,\n        self,\n    )\n    self._is_reported = True", "d": "Return a function that can be used as argument to Greenlet.link_exception() that will log the \nunhandled exception to the given logger."}, {"e": "<|fim_prefix|>    def filter_tasks_by_tags(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.include_tags is not None:\n            self.include_tags = set(self.include_tags)\n        if self.exclude_tags is not None:\n            self.exclude_tags = set(self.exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, self.include_tags, self.exclude_tags)<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "    def filter_tasks_by_tags(self):\n        if self.include_tags is not None:\n            self.include_tags = set(self.include_tags)\n        if self.exclude_tags is not None:\n            self.exclude_tags = set(self.exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, self.include_tags, self.exclude_tags)", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )<|fim_middle|>prepend url with hostname unless it's already an absolute URL<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and hasattr(item, \"task_set\")\n        and getattr(item, \"task_set\")\n        and not name.startswith('_')\n    )", "d": "prepend url with hostname unless it's already an absolute URL"}, {"e": "<|fim_prefix|>    def update_state(self, new_state):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self.state == new_state:\n            return\n\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n        self.state = new_state<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def update_state(self, new_state):\n        if self.state == new_state:\n            return\n\n        logger.debug(\"Updating state to %s, old state was %s\" % (new_state, self.state))\n        self.state = new_state", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple(int, float)]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple(int, float)]:\n        return None", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.history = []", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def get(self, name, method):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": false, "c": "def get(self, name, method):\n    entry = self.entries.get((name, method))\n    if not entry:\n        entry = StatsEntry(self, name, method, True)\n        self.entries[(name, method)] = entry\n    return entry", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom workers to master."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Start a greenlet that runs this User instance.\n\n:param group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Start a greenlet that runs this User instance.\n\n:param group: Group instance where the greenlet will be spawned.\n:type gevent_group: gevent.pool.Group\n:returns: The spawned greenlet."}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def write_stat_csvs(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats, stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(stats))", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def raise_for_status(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if hasattr(self, 'error') and self.error:\n        raise self.error<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def raise_for_status(self):\n    if hasattr(self, 'error') and self.error:\n        raise self.error", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def stop(self, force=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def stop(self, force=False):\n        if force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Just like self.assertTrue(a in b), but with a nicer default message.\nImplemented here to work with Python 2.6"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, tls_cert=None, tls_key=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, tls_cert=tls_cert, tls_key=tls_key)\n    return self.web_ui<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None, tls_cert=None, tls_key=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials, tls_cert=tls_cert, tls_key=tls_key)\n    return self.web_ui", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Sends a message to all attached worker nodes\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_user_instances([g.args[0] for g in self.user_greenlets])\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def status_code(self) -> int:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def status_code(self) -> int:\n    return self._response is not None and self._response.get_code() or 0", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def status_code(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._response is not None and self._response.get_code() or 0<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def status_code(self):\n    return self._response is not None and self._response.get_code() or 0", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalRunner)<|fim_middle|>Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalRunner)", "d": "Sends a message to master node\n\n:param msg_type: The type of the message to send\n:param data: Optional data to send"}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        locust_classes=self.locust_classes,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Check if a variable is a runnable (non-abstract) Locust class<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Check if a variable is a runnable (non-abstract) Locust class"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behavour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(locust_classes, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`<|file_separator|>", "l": false, "c": "def create_environment(locust_classes, options, events=None):\n    return Environment(\n        locust_classes=locust_classes,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Shortcut to the client :py:attr:`client <locust.User.client>` attribute of this TaskSet's :py:class:`User <locust.User>`"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Takes (name, object) tuple, returns True if it's a public Locust subclass.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Takes (name, object) tuple, returns True if it's a public Locust subclass."}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return (0, 0, True)<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return (0, 0, True)", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n* *headers* is an optional dict with HTTP request headers\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def failures_csv(stats):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failures_csv(stats):\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurrences\"',\n        ))\n    ]\n    for s in sort_stats(stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurrences,\n        ))\n    return \"\\n\".join(rows)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def start(self, group: Group):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = group.spawn(run_user, self)\n        self._group = group\n        return self._greenlet<|fim_middle|>Retrieve a StatsEntry instance by name and method<|file_separator|>", "l": false, "c": "    def start(self, group: Group):\n        def run_user(user):\n            \"\"\"\n            Main function for User greenlet. It's important that this function takes the user\n            instance as an argument, since we use greenlet_instance.args[0] to retrieve a reference to the\n            User instance.\n            \"\"\"\n            user.run()\n\n        self._greenlet = group.spawn(run_user, self)\n        self._group = group\n        return self._greenlet", "d": "Retrieve a StatsEntry instance by name and method"}, {"e": "<|fim_prefix|>def locust_init(environment, **kwargs):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def locust_init(environment, **kwargs):\n    if environment.web_ui:\n\n        @environment.web_ui.app.route(\"/content-length\")\n        def total_content_length():\n            \"\"\"\n            Add a route to the Locust web app, where we can see the total content-length\n            \"\"\"\n            return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>\"Return the contents of the 'failures' tab as a CSV.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "\"Return the contents of the 'failures' tab as a CSV."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Stop a stop_count of weighted users from the Group() object in self.users<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Stop a stop_count of weighted users from the Group() object in self.users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Loads the locust file as a module, similar to performing `import`<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Loads the locust file as a module, similar to performing `import`"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "Create a :class:`LocalLocustRunner <locust.runners.LocalLocustRunner>` instance for this Environment"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>total is the number of requests made\ncount is a dict {response_time: count}<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "total is the number of requests made\ncount is a dict {response_time: count}"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": "Get the response time that a certain number of percent of the requests\nfinished within. Arguments:\n\nresponse_times: A StatsEntry.response_times dict\nnum_requests: Number of request made (could be derived from response_times, \n              but we save some CPU cycles by using the value which we already store)\npercent: The percentile we want to calculate. Specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failures_csv():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurences,\n        ))\n    return \"\\n\".join(rows)<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def failures_csv():\n    Return the contents of the 'failures' tab as a CSV.\"\"\"\n    from . import runners\n    rows = [\n        \",\".join((\n            '\"Method\"',\n            '\"Name\"',\n            '\"Error\"',\n            '\"Occurences\"',\n        ))\n    ]\n\n    for s in sort_stats(runners.locust_runner.stats.errors):\n        rows.append('\"%s\",\"%s\",\"%s\",%i' % (\n            s.method,\n            s.name,\n            s.error,\n            s.occurences,\n        ))\n    return \"\\n\".join(rows)", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_WAITING\n        self._sleep(self.wait_time())\n        self._check_stop_condition()\n        self.user._state = LOCUST_STATE_RUNNING", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def create_environment(user_classes, shaper_class, options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shaper_class=shaper_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def create_environment(user_classes, shaper_class, options, events=None):\n    return Environment(\n        user_classes=user_classes,\n        shaper_class=shaper_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Make an HTTP GET request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *headers* is an optional dict with HTTP request headers"}, {"e": "<|fim_prefix|>def cpu_log_warning(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def cpu_log_warning(self):\n    if self.cpu_warning_emitted:\n        logger.warning(\"Loadgen CPU usage was too high at some point during the test! See https://docs.locust.io/en/stable/running-locust-distributed.html for how to distribute the load over multiple CPU cores or machines\")\n        return True\n    return False", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(six.iterkeys(count)):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def _build_url(self, path):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def _build_url(self, path):\n    if absolute_http_url_regexp.match(path):\n        return path\n    else:\n        return \"%s%s\" % (self.base_url, path)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>    def wait(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            self._taskset_instance.wait()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def wait(self):\n        self._taskset_instance.wait()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length received: %i\" % stats[\"content-length\"]<|fim_middle|>Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length received: %i\" % stats[\"content-length\"]", "d": "Make an HTTP POST request.\n\nArguments:\n\n* *path* is the relative path to request.\n* *data* dict with the data that will be sent in the body of the POST request\n\nExample::\n\n    client = HttpBrowser(\"http://example.com\")\n    client.post(\"/post\", {\"user\":\"joe_hill\"})"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>prepend url with hostname unless it's already an absolute URL <|file_separator|>", "l": false, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "prepend url with hostname unless it's already an absolute URL "}, {"e": "<|fim_prefix|>def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )<|fim_middle|>Reference to the :py:attr:`client <locust.core.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": false, "c": "def create_master_runner(self, master_bind_host=\"*\", master_bind_port=5557):\n    return self._create_runner(\n        MasterRunner,\n        master_bind_host=master_bind_host,\n        master_bind_port=master_bind_port,\n    )", "d": "Reference to the :py:attr:`client <locust.core.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Create a LocalLocustRunner instance for this Environment<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Create a LocalLocustRunner instance for this Environment"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Reference to the :py:attr:`client <locust.User.client>` attribute of the root\nUser instance."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)<|fim_middle|>Check if a variable is a runnable (non-abstract) User class<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalLocustRunner, self).__init__(environment)\n\n\n        def on_locust_error(locust_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.locust_error.add_listener(on_locust_error)", "d": "Check if a variable is a runnable (non-abstract) User class"}, {"e": "<|fim_prefix|>    def tick(self) -> Optional[Tuple[int, float]]:\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def tick(self) -> Optional[Tuple[int, float]]:\n        return None", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time<|fim_middle|>Write requests csv with header and data rows.<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time", "d": "Write requests csv with header and data rows."}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Total\", None, use_response_times_cache=True)\n    self.entries = {}\n    self.errors = {}\n    self.start_time = None", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Event handler that get triggered on every successful request<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Event handler that get triggered on every successful request"}, {"e": "<|fim_prefix|>def stats_writer(stats, base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def stats_writer(stats, base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_stat_csvs(stats, base_filepath, stats_history_enabled)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def stats_writer(base_filepath):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def stats_writer(base_filepath):\n    while True:\n        write_stat_csvs(base_filepath)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def stats_history_csv_header():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'<|fim_middle|>:param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed.<|file_separator|>", "l": false, "c": "def stats_history_csv_header():\n    return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'", "d": ":param use_response_times_cache: The value of use_response_times_cache will be set for each StatsEntry()\n                                 when they are created. Settings it to False saves some memory and CPU \n                                 cycles which we can do on Worker nodes where the response_times_cache \n                                 is not needed."}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def text(self):\n    if self.content is None:\n        return None\n    self.encoding = self.encoding or self.headers.get('content-type', '').partition(\"charset=\")[2] or 'utf-8'\n    return unicode(self.content, self.encoding, errors='replace')", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, six.string_types):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def test_streaming_response(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": false, "c": "def test_streaming_response(self):\n    s = FastHttpSession(\"http://127.0.0.1:%i\" % self.port)\n    r = s.get(\"/streaming/30\")\n\n\n    self.assertGreater(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n    global_stats.clear_all()\n\n\n    r = s.get(\"/streaming/30\", stream=True)\n    self.assertGreaterEqual(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 0)\n    self.assertLess(global_stats.get(\"/streaming/30\", method=\"GET\").avg_response_time, 250)\n\n\n    _ = r.content", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>def client(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self.user.client<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def client(self):\n    return self.user.client", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>Returns current actual number of users from the runner<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "Returns current actual number of users from the runner"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Returns the text content of the response as a decoded string\n(unicode on python2)<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Returns the text content of the response as a decoded string\n(unicode on python2)"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    to_kill = []\n    for g in self.locusts:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_kill.append(user)\n                bucket.remove(l)\n                break\n    self.kill_locust_instances(to_kill)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            return None<|fim_middle|>If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task.<|file_separator|>", "l": false, "c": "    def tick(self):\n        return None", "d": "If *reschedule* is True and the InterruptTaskSet is raised inside a nested TaskSet,\nthe parent TaskSet whould immediately reschedule another task."}, {"e": "<|fim_prefix|>def median_from_dict(total, count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]<|fim_middle|>Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x.<|file_separator|>", "l": false, "c": "def median_from_dict(total, count):\n    pos = (total - 1) / 2\n    for k in sorted(count.keys()):\n        if pos < count[k]:\n            return k\n        pos -= count[k]", "d": "Send an HTTP request, and catch any exception that might occur due to connection problems.\n\nSafe mode has been removed from requests 1.x."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.total.reset()\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.start_time = time.time()\n    self.num_requests = 0\n    self.num_failures = 0\n    for r in six.itervalues(self.entries):\n        r.reset()", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return calculate_response_time_percentile(self.response_times, self.num_requests, percent)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get_response_time_percentile(self, percent):\n    return calculate_response_time_percentile(self.response_times, self.num_requests, percent)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def stats_writer(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def stats_writer(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats_history.csv', 'w') as f:\n        f.write(stats_history_csv_header())\n    while True:\n        write_csv_files(environment, base_filepath, full_history)\n        gevent.sleep(CSV_STATS_INTERVAL_SEC)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    self.environment.events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Serialize a RequestStats instance, then serialize it through a Message, \nand unserialize the whole thing again. This is done \"IRL\" when stats are sent \nfrom slaves to master."}, {"e": "<|fim_prefix|>def task(weight=1):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def task(weight=1):\n    def decorator_func(func):\n        func.locust_task_weight = weight\n        return func\n\n    \"\"\"\n    Check if task was used without parentheses (not called), like this::\n\n        @task\n        def my_task()\n            pass\n    \"\"\"\n    if callable(weight):\n        func = weight\n        weight = 1\n        return decorator_func(func)\n    else:\n        return decorator_func", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def __init__(self, reschedule=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.reschedule = reschedule<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def __init__(self, reschedule=True):\n    self.reschedule = reschedule", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict.<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": "This event is triggered on the master instance when a new stats report arrives\nfrom a slave. Here we just add the content-length to the master's aggregated\nstats dict."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as a failure.\n\nexc can be either a python exception, or a string in which case it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == b\"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Writes the csv files for the locust run.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Writes the csv files for the locust run."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None, client_id=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None, client_id=None):\n        if client_id:\n            logger.debug(f\"Sending {msg_type} message to client {client_id}\")\n            self.server.send_to_client(Message(msg_type, data, client_id))\n        else:\n            for client in self.clients.all:\n                logger.debug(f\"Sending {msg_type} message to client {client.id}\")\n                self.server.send_to_client(Message(msg_type, data, client.id))", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(response_times.keys(), reverse=True):\n        processed_count += response_times[response_time]\n        if(num_requests - processed_count <= num_of_request):\n            return response_time\n\n    return 0", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def __init__(self, use_response_times_cache=True):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)<|fim_middle|>Returns the text content of the response as a decoded string<|file_separator|>", "l": false, "c": "def __init__(self, use_response_times_cache=True):\n    self.use_response_times_cache = use_response_times_cache\n    self.entries = {}\n    self.errors = {}\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)", "d": "Returns the text content of the response as a decoded string"}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()<|fim_middle|>Test a request to an endpoint that returns a streaming response<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()", "d": "Test a request to an endpoint that returns a streaming response"}, {"e": "<|fim_prefix|>def get(self, path, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def get(self, path, headers={}, name=None):\n    url = self.base_url + path\n    request = urllib2.Request(url, None, headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return HttpResponse(url, name, f.code, data, f.info)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def apply_tags(self, include_tags=None, exclude_tags=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if include_tags is not None:\n            include_tags = set(include_tags)\n        if exclude_tags is not None:\n            exclude_tags = set(exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, include_tags, exclude_tags)<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "    def apply_tags(self, include_tags=None, exclude_tags=None):\n        if include_tags is not None:\n            include_tags = set(include_tags)\n        if exclude_tags is not None:\n            exclude_tags = set(exclude_tags)\n\n        for user_class in self.user_classes:\n            filter_tasks_by_tags(user_class, include_tags, exclude_tags)", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def send_message(self, msg_type, data=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "    def send_message(self, msg_type, data=None):\n        logger.debug(\"Sending {msg_type} message to master\")\n        self.client.send(Message(msg_type, data, self.client_id))", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == type(g.args[0]):\n                dying.append(g)\n                bucket.remove(l)\n                break\n    self.kill_locust_greenlets(dying)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def text(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        try:\n        content = str(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = str(self.content, errors='replace')\n    return content<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def text(self):\n    try:\n        content = str(self.content, self.apparent_encoding, errors='replace')\n    except (LookupError, TypeError):\n\n\n\n\n\n\n        content = str(self.content, errors='replace')\n    return content", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def stop(self, force=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            if self._greenlet is greenlet.getcurrent():\n\n            self._group.killone(self._greenlet, block=False)\n            return True\n        elif force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def stop(self, force=False):\n        if self._greenlet is greenlet.getcurrent():\n\n            self._group.killone(self._greenlet, block=False)\n            return True\n        elif force or self._state == LOCUST_STATE_WAITING:\n            self._group.killone(self._greenlet)\n            return True\n        elif self._state == LOCUST_STATE_RUNNING:\n            self._state = LOCUST_STATE_STOPPING\n            return False", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def success(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def success(self):\n    self._request_success.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n    )\n    self._is_reported = True", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerLocustRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def stop(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def stop(self):\n    self.state = STATE_CLEANUP\n\n    if self.hatching_greenlet and not self.hatching_greenlet.ready():\n        self.hatching_greenlet.kill(block=True)\n    self.stop_users(self.user_count)\n    self.state = STATE_STOPPED\n    self.cpu_log_warning()", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Make the running user sleep for a duration defined by the Locust.wait_time\nfunction (or TaskSet.wait_time function if it's been defined).\n\nThe user can also be killed gracefully while it's sleeping, so calling this\nmethod within a task makes it possible for a user to be killed mid-task, even if you've\nset a stop_timeout. If this behaviour is not desired you should make the user wait using\ngevent.sleep() instead."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>    def tick(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            run_time = self.get_run_time()\n\n        return (0, 0, True)<|fim_middle|>Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles.<|file_separator|>", "l": false, "c": "    def tick(self):\n        run_time = self.get_run_time()\n\n        return (0, 0, True)", "d": "Returns the delta between two {response_times:request_count} dicts.\n\nUsed together with the response_times cache to get the response times for the \nlast X seconds, which in turn is used to calculate the current response time \npercentiles."}, {"e": "<|fim_prefix|>def reset_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def reset_all(self):\n    self.total.reset()\n    self.errors = {}\n    for r in self.entries.values():\n        r.reset()\n    self.history = []", "d": "Writes the requests, distribution, and failures csvs."}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(six.iterkeys(self.response_times), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>    def get_response_time_percentile(self, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "    def get_response_time_percentile(self, percent):\n        num_of_request = int((self.num_requests * percent))\n\n        processed_count = 0\n        for response_time in sorted(self.response_times.iterkeys(), reverse=True):\n            processed_count += self.response_times[response_time]\n            if((self.num_requests - processed_count) <= num_of_request):\n                return response_time", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv(environment.stats))\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv(environment.stats))", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def write_stat_csvs(base_filepath, stats_history_enabled=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def write_stat_csvs(base_filepath, stats_history_enabled=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        f.write(requests_csv())\n\n    with open(base_filepath + '_stats_history.csv', 'a') as f:\n        f.write(stats_history_csv(stats_history_enabled) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        f.write(failures_csv())", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def total_content_length():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \"Total content-length recieved: %i\" % stats[\"content-length\"]<|fim_middle|>Stop a running load test by stopping all running users<|file_separator|>", "l": false, "c": "def total_content_length():\n    return \"Total content-length recieved: %i\" % stats[\"content-length\"]", "d": "Stop a running load test by stopping all running users"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if not isinstance(exc, Exception):\n        exc = CatchResponseError(exc)\n    self._manual_result = exc", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Called at the end of the test to repeat the warning & return the status<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Called at the end of the test to repeat the warning & return the status"}, {"e": "<|fim_prefix|>def post(self, path, data, headers={}, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")<|file_separator|>", "l": false, "c": "def post(self, path, data, headers={}, name=None):\n    request = urllib2.Request(self.base_url + path, urllib.urlencode(data), headers)\n    f = self.opener.open(request)\n    data = f.read()\n    f.close()\n    return data", "d": "Report the response as a failure.\n\nif exc is anything other than a python exception (like a string) it will\nbe wrapped inside a CatchResponseError. \n\nExample::\n\n    with self.client.get(\"/\", catch_response=True) as response:\n        if response.content == \"\":\n            response.failure(\"No data\")"}, {"e": "<|fim_prefix|>def create_local_runner(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_local_runner(self):\n    return self._create_runner(LocalLocustRunner, locust_classes=self.locust_classes)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def is_shape_class(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, LoadTestShape)\n        and item.__dict__['__module__'] != 'locust.shape'\n    )<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "def is_shape_class(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, LoadTestShape)\n        and item.__dict__['__module__'] != 'locust.shape'\n    )", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>Returns a StatsEntry which is an aggregate of all stats entries \nwithin entries.<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": "Returns a StatsEntry which is an aggregate of all stats entries \nwithin entries."}, {"e": "<|fim_prefix|>def create_environment(options, events=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_environment(options, events=None):\n    return Environment(\n        events=events,\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )<|fim_middle|>Go through all stats entries and reset them to zero<|file_separator|>", "l": false, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n    )", "d": "Go through all stats entries and reset them to zero"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Create an Environment instance from options<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Create an Environment instance from options"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Create a :class:`MasterLocustRunner <locust.runners.MasterLocustRunner>` instance for this Environment\n\n:param master_bind_host: Interface/host that the master should use for incoming worker connections. \n                         Defaults to \"*\" which means all interfaces.\n:param master_bind_port: Port that the master should listen for incoming worker connections on"}, {"e": "<|fim_prefix|>def is_locust(tup):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped.<|file_separator|>", "l": false, "c": "def is_locust(tup):\n    name, item = tup\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "Returns a tuple with 2 elements to control the running load test:\n\n    user_count -- Total user count\n    spawn_rate -- Number of users to start/stop per second when changing number of users\n\nIf `None` is returned then the running load test will be stopped."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Kill a kill_count of weighted locusts from the Group() object in self.locusts<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Kill a kill_count of weighted locusts from the Group() object in self.locusts"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave.<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super().__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "This event is triggered on the slave instances every time a stats report is\nto be sent to the locust master. It will allow us to add our extra content-length\ndata to the dict that is being sent, and then we clear the local stats in the slave."}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def kill_locusts(self, kill_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)<|fim_middle|>Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def kill_locusts(self, kill_count):\n    bucket = self.weight_locusts(kill_count)\n    kill_count = len(bucket)\n    self.num_clients -= kill_count\n    logger.info(\"Killing %i locusts\" % kill_count)\n    dying = []\n    for g in self.locusts:\n        for l in bucket:\n            if l == g.args[0]:\n                dying.append(g)\n                bucket.remove(l)\n                break\n    for g in dying:\n        self.locusts.killone(g)\n    events.hatch_complete.fire(user_count=self.num_clients)", "d": "Create a :class:`WorkerLocustRunner <locust.runners.WorkerLocustRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Add a route to the Locust web app, where we can see the total content-length<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, basestring):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Add a route to the Locust web app, where we can see the total content-length"}, {"e": "<|fim_prefix|>def post(self, path, data, name=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data<|fim_middle|>The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed.<|file_separator|>", "l": false, "c": "def post(self, path, data, name=None):\n    f = self.opener.open(self.base_url + path, urllib.urlencode(data))\n    data = f.read()\n    f.close()\n    return data", "d": "The value of use_response_times_cache will be set for each StatsEntry() when they are created.\nSettings it to False saves some memory and CPU cycles which we can do on worker nodes where \nthe response_times_cache is not needed."}, {"e": "<|fim_prefix|>def create_worker_runner(self, master_host, master_port):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )<|fim_middle|>Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "def create_worker_runner(self, master_host, master_port):\n    self.stats = RequestStats(use_response_times_cache=False)\n    return self._create_runner(\n        WorkerRunner,\n        master_host=master_host,\n        master_port=master_port,\n    )", "d": "Creates a :class:`WebUI <locust.web.WebUI>` instance for this Environment and start running the web server\n\n:param host: Host/interface that the web server should accept connections to. Defaults to \"*\"\n             which means all interfaces\n:param port: Port that the web server should listen to\n:param auth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def create_web_ui(self, host=\"\", port=8089, auth_credentials=None):\n    self.web_ui = WebUI(self, host, port, auth_credentials=auth_credentials)\n    return self.web_ui", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def create_environment(user_classes, options, events=None, shape_class=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "def create_environment(user_classes, options, events=None, shape_class=None):\n    return Environment(\n        user_classes=user_classes,\n        shape_class=shape_class,\n        tags=options.tags,\n        exclude_tags=options.exclude_tags,\n        events=events,\n        host=options.host,\n        reset_stats=options.reset_stats,\n        step_load=options.step_load,\n        stop_timeout=options.stop_timeout,\n        parsed_options=options,\n    )", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def create_environment(options):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return Environment(\n        host=options.host,\n        options=options,\n    )<|fim_middle|>Raise any connection errors that occured during the request<|file_separator|>", "l": false, "c": "def create_environment(options):\n    return Environment(\n        host=options.host,\n        options=options,\n    )", "d": "Raise any connection errors that occured during the request"}, {"e": "<|fim_prefix|>    def shutdown(code=0):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "    def shutdown(code=0):\n        logger.info(\"Shutting down (exit code %s), bye.\" % code)\n\n        events.quitting.fire()\n        events.parallel_quitting.fire()\n        print_stats(runners.locust_runner.request_stats)\n        print_percentile_stats(runners.locust_runner.request_stats)\n        if options.csvfilebase:\n            write_stat_csvs(options.csvfilebase)\n        print_error_report()\n        sys.exit(code)", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def is_locust(item):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )<|fim_middle|>We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master<|file_separator|>", "l": false, "c": "def is_locust(item):\n    return bool(\n        inspect.isclass(item)\n        and issubclass(item, Locust)\n        and item.abstract == False\n    )", "d": "We need somewhere to store the stats.\n\nOn the master node stats will contain the aggregated sum of all content-lengths,\nwhile on the worker nodes this will be the sum of the content-lengths since the\nlast stats report was sent to the master"}, {"e": "<|fim_prefix|>def stop_users(self, user_count):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)<|fim_middle|>Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass<|file_separator|>", "l": false, "c": "def stop_users(self, user_count):\n    bucket = self.weight_users(user_count)\n    user_count = len(bucket)\n    logger.info(\"Stopping %i users\" % user_count)\n    to_stop = []\n    for g in self.user_greenlets:\n        for l in bucket:\n            user = g.args[0]\n            if l == type(user):\n                to_stop.append(user)\n                bucket.remove(l)\n                break\n    self.stop_user_instances(to_stop)\n    self.environment.events.hatch_complete.fire(user_count=self.user_count)", "d": "Used as a convenience decorator to be able to declare tasks for a User or a TaskSet\ninline in the class. Example::\n\n    class ForumPage(TaskSet):\n        @task(100)\n        def read_thread(self):\n            pass\n\n        @task(7)\n        def create_thread(self):\n            pass"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>Creates a WebUI instance for this Environment and start running the web server\n\nArguments:\nhost: Host/interface that the web server should accept connections to. Defaults to \"*\"\n      which means all interfaces\nport: Port that the web server should listen to\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": "Creates a WebUI instance for this Environment and start running the web server\n\nArguments:\nhost: Host/interface that the web server should accept connections to. Defaults to \"*\"\n      which means all interfaces\nport: Port that the web server should listen to\nauth_credentials: If provided (in format \"username:password\") basic auth will be enabled"}, {"e": "<|fim_prefix|>    def __init__(self, environment):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n            super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)<|fim_middle|>:param environment: Environment instance<|file_separator|>", "l": false, "c": "    def __init__(self, environment):\n        super(LocalRunner, self).__init__(environment)\n\n\n        def on_user_error(user_instance, exception, tb):\n            formatted_tb = \"\".join(traceback.format_tb(tb))\n            self.log_exception(\"local\", str(exception), formatted_tb)\n        self.environment.events.user_error.add_listener(on_user_error)", "d": ":param environment: Environment instance"}, {"e": "<|fim_prefix|>def calculate_response_time_percentile(response_times, num_requests, percent):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if((num_requests - processed_count) <= num_of_request):\n            return response_time<|fim_middle|>Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to<|file_separator|>", "l": false, "c": "def calculate_response_time_percentile(response_times, num_requests, percent):\n    num_of_request = int((num_requests * percent))\n\n    processed_count = 0\n    for response_time in sorted(six.iterkeys(response_times), reverse=True):\n        processed_count += response_times[response_time]\n        if((num_requests - processed_count) <= num_of_request):\n            return response_time", "d": "Create a :class:`WorkerRunner <locust.runners.WorkerRunner>` instance for this Environment\n\n:param master_host: Host/IP of a running master node\n:param master_port: Port on master node to connect to"}, {"e": "<|fim_prefix|>def clear_all(self):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}<|fim_middle|>Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()<|file_separator|>", "l": false, "c": "def clear_all(self):\n    self.total = StatsEntry(self, \"Aggregated\", None, use_response_times_cache=self.use_response_times_cache)\n    self.entries = {}\n    self.errors = {}", "d": "Report the response as successful\n\nExample::\n\n    with self.client.get(\"/does/not/exist\", catch_response=True) as response:\n        if response.status_code == 404:\n            response.success()"}, {"e": "<|fim_prefix|>def write_csv_files(environment, base_filepath, full_history=False):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)<|fim_middle|>Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue.<|file_separator|>", "l": false, "c": "def write_csv_files(environment, base_filepath, full_history=False):\n    with open(base_filepath + '_stats.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        requests_csv(environment.stats, csv_writer)\n\n    with open(stats_history_file_name(base_filepath), 'a') as f:\n        f.write(stats_history_csv_rows(environment, full_history) + \"\\n\")\n\n    with open(base_filepath + '_failures.csv', 'w') as f:\n        csv_writer = csv.writer(f)\n        failures_csv(environment.stats, csv_writer)", "d": "Add a task to the User's task execution queue.\n\n:param task_callable: User task to schedule.\n:param args: Arguments that will be passed to the task callable.\n:param kwargs: Dict of keyword arguments that will be passed to the task callable.\n:param first: Optional keyword argument. If True, the task will be put first in the queue."}, {"e": "<|fim_prefix|>def stats_history_csv_header():\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'<|fim_middle|>Remove all stats entries and errors<|file_separator|>", "l": false, "c": "def stats_history_csv_header():\n    return \",\".join((\n        \"Timestamp\",\n        \"User Count\",\n        \"Type\",\n        \"Name\",\n        \"Requests/s\",\n        \"Failures/s\",\n        \",\".join(get_readable_percentiles(PERCENTILES_TO_REPORT)),\n        \"Total Request Count\",\n        \"Total Failure Count\",\n        \"Total Median Response Time\",\n        \"Total Average Response Time\",\n        \"Total Min Response Time\",\n        \"Total Max Response Time\",\n        \"Total Average Content Size\",\n    )) + '\\n'", "d": "Remove all stats entries and errors"}, {"e": "<|fim_prefix|>def failure(self, exc):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True<|fim_middle|>Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0<|file_separator|>", "l": false, "c": "def failure(self, exc):\n    if isinstance(exc, str):\n        exc = CatchResponseError(exc)\n\n    events.request_failure.fire(\n        request_type=self.locust_request_meta[\"method\"],\n        name=self.locust_request_meta[\"name\"],\n        response_time=self.locust_request_meta[\"response_time\"],\n        response_length=self.locust_request_meta[\"content_size\"],\n        exception=exc,\n    )\n    self._is_reported = True", "d": "Get the response time that a certain number of percent of the requests\nfinished within.\n\nPercent specified in range: 0.0 - 1.0"}, {"e": "<|fim_prefix|>def assertIn(self, member, container, msg=None):\n\n    \"\"\"<|fim_suffix|>\"\"\"\n        if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))<|fim_middle|>Writes the requests, distribution, and failures csvs.<|file_separator|>", "l": false, "c": "def assertIn(self, member, container, msg=None):\n    if member not in container:\n        standardMsg = '%s not found in %s' % (safe_repr(member),\n                                              safe_repr(container))\n        self.fail(self._formatMessage(msg, standardMsg))", "d": "Writes the requests, distribution, and failures csvs."}]